## 设计箱内的工具[1][2]代表第一章,第二章
- oo基础
    1. 抽象: 抽象父类+接口
    2. 封装: set方法
    3. 多态: 父类 x = new 子类();
    4. 继承: 子类继承父类,实现接口
- oo原则
    1. 封装变化: 分离变化和不变的部分
    2. 多用组合,少用继承: FlyBehavior
    3. 针对接口编程,不针对实现编程: 策略模式
    4. [2]为交互对象之间的松耦合设计而努力
    5. [3]对扩展开放,对修改关闭
    6. [6]依赖倒置原则,指导我们避免依赖具体的类型,要尽量依赖抽象
    7. [7]最少知识原则: 只和你的密友谈话.(尽量少见对象之间的交互)
    8. [8]别找我,我会找你(超类调用子类,子类不调用超类(相同的方法除外))
    9. [9]类应该只有一个改变的理由
- oo模式
    1. 策略模式--定义算法族,封装起来,让它们可以互相替换,而不影响使用算法的客户端
    2. [2]观察者模式--在对象之间定义一对多的依赖,当subject改变时,所有的observer都会收到通知
    3. [3]装饰者模式--既组合又继承,组合维持旧功能,继承扩展新功能
    4. [4]抽象工厂模式--一个创建对象的接口
    5. [4]工厂方法模式--一个创建对象的抽象方法,具体实现由子类决定
    6. [5]单例模式--实例全局唯一,并且只提供一个获取方法
    7. [6]命令模式--把请求封装成对象,这样可以用不同的请求~队列~日志,还支持撤销
    8. [7]适配器模式--把接口转换成客户希望的接口(1对1)
    9. [7]外观模式--提供一个统一的接口,用来访问子系统的一群接口(1对多)
    10. [8]模板方法模式--在超类定义算法的骨架,把算法的实现延迟到子类,(可以加钩子)
    11. [9]迭代器模式--提供一个方法访问集合中的元素,而不暴露集合的内部表示
    12. [9]组合模式--把对象组合成树形结构,并使树中的节点具有一致的接口
    13. [10]状态模式--把多个状态封装成多个对象,把行为都委托给状态
    14. [11]代理模式--一个类代表另一个类的接口,像装饰者
- 要点[1]
  1. OO基础,不足以设计良好的OO
  2. 良好的OO设计,必须可复用~可扩展~可维护
  3. 模式可以让我们设计出良好的OO
  4. 模式是经历考研的设计经验
  5. 模式不是代码,是通用的解决方案
  6. 模式不是发明的,而是发现的
  7. 多数模式面向于软件变化
  8. 多数模式允许独立改变某些部分
  9. 我们会把系统中变化的部分封装起来(FlyBehavior)
  10. 模式让开发有共用术语
- 要点[2]
  1. 观察者模式定义了一对多的关系(一个Subject,多个Observer)
  2. Subject用一个共同接口更新所有Observer
  3. Subject不知道Observer的实现细节,只知道Observer接口
  4. push: Subject推数据到Observer; pull: Observer从Subject拉数据. 更倾向于push
  5. 多个Observer不依赖次序
  6. Java有内置的观察者模式: java.util.Observable
  7. Java的观察者模式有一些问题,必要时自己实现
- 要点[3]
  1. 继承可以扩展,但不是最佳的扩展方式
  2. 设计要允许扩展,不需要修改
  3. 组合和委托可以在运行时加上新的行为
  4. 除了继承,装饰者模式也可以扩展行为
  5. 装饰者模式意味着一群装饰者类
  6. 装饰者类和被装饰的组件类型相同
  7. 装饰者可以在运行前后加上自己的功能
  8. 可以有无数个装饰者
  9. 装饰者对组件的客户是透明的
  10. 装饰者容易让对象太多
- 要点[4]
  1. 所有的工厂都是封装对象的创建
  2. 简单工厂不是设计模式
  3. 工厂方法使用继承
  4. 抽象工厂使用对象组合
  5. 所有工厂模式都减少client和具体类的依赖